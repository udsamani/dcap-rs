use anyhow::{anyhow, bail};
use sha2::{Digest, Sha256};
use zerocopy::little_endian;

use crate::{
    types::{quote::QuoteCertData, report::EnclaveReportBody},
    utils,
};

use super::{CertificationKeyType, PckCertChainData};

/// Signature data for SGX Quotes
///
/// In the intel docs, this is A 4.4: "ECDSA 2560bit Quote Signature Data Structure"
///
/// This can be used to validate that the quoting enclave itself is valid, and then that
/// the quoting enclave has signed the ISV enclave report.
#[derive(Debug)]
pub struct QuoteSignatureData<'a> {
    /// Signature of the report header + report by the attestation key.
    pub isv_signature: &'a [u8],

    /// The public key used to generate the isv_signature.
    pub attestation_pub_key: &'a [u8],

    /// Report of the quoting enclave.
    pub qe_report_body: EnclaveReportBody,

    /// Signature of the quoting enclave report using the PCK cert key.
    pub qe_report_signature: &'a [u8],

    /// Auth data for the quote
    pub auth_data: &'a [u8],

    /// Cert data
    pub cert_data: QuoteCertData<'a>,
}

impl<'a> QuoteSignatureData<'a> {
    pub fn read(bytes: &mut &'a [u8], version: u16) -> anyhow::Result<Self> {
        let signature_len = utils::read_from_bytes::<little_endian::U32>(bytes)
            .ok_or_else(|| anyhow!("underflow reading signature length"))?
            .get();

        if bytes.len() < signature_len as usize {
            return Err(anyhow!("underflow reading signature"));
        }

        match version {
            3 => Self::read_v3_signature(bytes),
            4 => Self::read_v4_signature(bytes),
            _ => Err(anyhow!("unsupported quote version")),
        }
    }

    fn read_v3_signature(bytes: &mut &'a [u8]) -> anyhow::Result<Self> {
        let isv_signature = utils::read_bytes(bytes, 64);

        let attestation_pub_key = utils::read_bytes(bytes, 64);

        let qe_report_body = utils::read_from_bytes::<EnclaveReportBody>(bytes)
            .ok_or_else(|| anyhow!("underflow reading enclave report body"))?;

        let qe_report_signature = utils::read_bytes(bytes, 64);

        let auth_data_size = utils::read_from_bytes::<little_endian::U16>(bytes)
            .ok_or_else(|| anyhow!("Failed to read auth data size"))?
            .get();

        if bytes.len() < auth_data_size as usize {
            return Err(anyhow!("buffer underflow"));
        }

        let auth_data = utils::read_bytes(bytes, auth_data_size as usize);
        let cert_data = QuoteCertData::read(bytes)?;

        Ok(QuoteSignatureData {
            isv_signature,
            attestation_pub_key,
            qe_report_body,
            qe_report_signature,
            auth_data,
            cert_data,
        })
    }

    fn read_v4_signature(bytes: &mut &'a [u8]) -> anyhow::Result<Self> {
        let isv_signature = utils::read_bytes(bytes, 64);

        let attestation_pub_key = utils::read_bytes(bytes, 64);

        let mut cert_data_struct = QuoteCertData::read(bytes)?;

        if cert_data_struct.cert_key_type.get() != CertificationKeyType::EcdsaSigAuxData as u16 {
            return Err(anyhow!(
                "cannot transform cert data into quoting enclave report cert data"
            ));
        }

        // Parse the QE report
        let qe_report_body =
            utils::read_from_bytes::<EnclaveReportBody>(&mut cert_data_struct.cert_data)
                .ok_or_else(|| anyhow!("underflow reading enclave report body"))?;

        // Parse the QE report signature
        let qe_report_signature = utils::read_bytes(&mut cert_data_struct.cert_data, 64);

        // Read auth data size and auth data
        let auth_data_size =
            utils::read_from_bytes::<little_endian::U16>(&mut cert_data_struct.cert_data)
                .ok_or_else(|| anyhow!("Failed to read auth data size"))?;

        if cert_data_struct.cert_data.len() < auth_data_size.get() as usize {
            return Err(anyhow!("buffer underflow"));
        }

        let qe_auth_data = utils::read_bytes(
            &mut cert_data_struct.cert_data,
            auth_data_size.get() as usize,
        );
        let cert_data = QuoteCertData::read(&mut cert_data_struct.cert_data)?;

        Ok(QuoteSignatureData {
            isv_signature,
            attestation_pub_key,
            qe_report_body,
            qe_report_signature,
            auth_data: qe_auth_data,
            cert_data,
        })
    }

    pub fn get_pck_cert_chain(&self) -> anyhow::Result<PckCertChainData> {
        self.cert_data.as_pck_cert_chain_data()
    }

    /// Verfiy the report generated by the quoting enclave.
    ///
    /// By specification, the quoting enclave report data `sgx_report_data_bytes` must b e
    /// SHA256(ECDSA Attestation Key || QE Authentication Data) || 32- 0x00s
    pub fn verify_qe_report(&self) -> anyhow::Result<()> {
        let mut hasher = Sha256::new();

        hasher.update(self.attestation_pub_key);
        hasher.update(self.auth_data);
        let digest = hasher.finalize();
        assert_eq!(digest.len(), 32);

        if *digest != self.qe_report_body.user_report_data[..digest.len()] {
            bail!("Quoting enclave report should be hash of attestation key and auth data");
        }

        if self.qe_report_body.user_report_data[digest.len()..] != [0; 32] {
            bail!("Quoting enclave report should be 32 zero bytes padded");
        }

        Ok(())
    }
}

#[derive(Debug, zerocopy::FromBytes, zerocopy::FromZeroes)]
pub struct EcdsaSignatureHeader {
    pub isv_signature: [u8; 64],
    pub attestation_pub_key: [u8; 64],
}
